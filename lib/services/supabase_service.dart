import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/stock_item.dart';
import '../models/stock_transaction.dart';

class SupabaseService {
  final SupabaseClient _client = Supabase.instance.client;

  // ==================== STOCK ITEMS ====================

  /// Fetch all inventory items for the authenticated user
  Future<List<StockItem>> getStockItems() async {
    try {
      // Debug: Check auth status
      final user = _client.auth.currentUser;
      print('DEBUG getStockItems - Auth User: ${user?.id ?? "NO USER"}');
      print('DEBUG getStockItems - Is Anonymous: ${user?.isAnonymous ?? true}');
      
      final response = await _client
          .from('inventory_items')
          .select()
          .order('created_at', ascending: false);
      // Debug: log raw response
      // ignore: avoid_print
      print('DEBUG getStockItems response: $response');
      print('DEBUG getStockItems count: ${(response as List).length}');

      return (response as List)
          .map((json) => StockItem.fromJson(json))
          .toList();
    } catch (e) {
      // ignore: avoid_print
      print('DEBUG getStockItems error: $e');
      throw Exception('Failed to fetch stock items: $e');
    }
  }

  /// Create a new inventory item
  Future<StockItem> createStockItem(StockItem item) async {
    try {
      final data = item.toJson();
      // Remove fields that will be auto-generated by the database
      data.remove('id');
      data.remove('created_at');
      data.remove('updated_at');

      final response = await _client
          .from('inventory_items')
          .insert(data)
          .select()
          .single();

      return StockItem.fromJson(response);
    } catch (e) {
      throw Exception('Failed to create stock item: $e');
    }
  }

  /// Update an existing inventory item
  Future<StockItem> updateStockItem(String id, StockItem item) async {
    try {
      final data = item.toJson();
      // Don't update these fields
      data.remove('id');
      data.remove('owner_id');
      data.remove('created_at');

      final response = await _client
          .from('inventory_items')
          .update(data)
          .eq('id', id)
          .select()
          .single();

      return StockItem.fromJson(response);
    } catch (e) {
      throw Exception('Failed to update stock item: $e');
    }
  }

  /// Delete an inventory item
  Future<void> deleteStockItem(String id) async {
    try {
      await _client.from('inventory_items').delete().eq('id', id);
    } catch (e) {
      throw Exception('Failed to delete stock item: $e');
    }
  }

  // ==================== STOCK TRANSACTIONS ====================

  /// Fetch all transactions for the authenticated user
  Future<List<StockTransaction>> getTransactions() async {
    try {
      final response = await _client
          .from('stock_transactions')
          .select()
          .order('occurred_at', ascending: false);

      return (response as List)
          .map((json) => StockTransaction.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to fetch transactions: $e');
    }
  }

  /// Create a new transaction
  Future<StockTransaction> createTransaction(StockTransaction transaction) async {
    try {
      final data = transaction.toJson();
      // Remove fields that will be auto-generated by the database
      data.remove('id');
      data.remove('created_at');
      data.remove('updated_at');

      final response = await _client
          .from('stock_transactions')
          .insert(data)
          .select()
          .single();

      return StockTransaction.fromJson(response);
    } catch (e) {
      throw Exception('Failed to create transaction: $e');
    }
  }

  /// Get transactions for a specific item
  Future<List<StockTransaction>> getTransactionsForItem(String itemId) async {
    try {
      final response = await _client
          .from('stock_transactions')
          .select()
          .eq('item_id', itemId)
          .order('occurred_at', ascending: false);

      return (response as List)
          .map((json) => StockTransaction.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to fetch item transactions: $e');
    }
  }
}
